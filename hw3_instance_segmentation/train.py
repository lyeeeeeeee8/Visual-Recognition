#!/usr/bin/env python3
"""
Train a Mask R‑CNN for 4‑class cell–instance segmentation.

Key features
------------
* COCO‑style dataset registration (generated by `annotation.py`)
* Custom data‑augmentation: flip, ±5° rotation, colour jitter
* ResNet‑101‑DC5 backbone with tuned anchor sizes
* Best‑AP checkpointing + automatic loss curve plotting
"""

# ‑‑‑ Standard library
import csv
import os

# ‑‑‑ Third‑party
import matplotlib.pyplot as plt
import numpy as np
import torch
from detectron2 import model_zoo
from detectron2.config import get_cfg
from detectron2.data import (
    DatasetCatalog,
    MetadataCatalog,
    DatasetMapper,
    build_detection_train_loader,
    transforms as T,
)
from detectron2.data.datasets import register_coco_instances
from detectron2.engine import BestCheckpointer, DefaultTrainer, HookBase
from detectron2.evaluation import COCOEvaluator

# ---------------------------------------------------------------------#
# ----------------------------  CONSTANTS  ----------------------------#
# ---------------------------------------------------------------------#
# Dataset paths
DATASET_NAME = "dlcvhw3_dataset_train"
JSON_PATH = "/home/hscc/EN/hw3_detectron/dataset/train.json"
IMG_DIR = "/home/hscc/EN/hw3_detectron/dataset/train"

# Training hyper‑parameters
BATCH_SIZE = 2
MAX_ITER = 24000
EVAL_PERIOD = 1000
NUM_CLASSES = 4
ANCHOR_SIZES = [8, 16, 32, 64, 128]

# Model & output
MODEL_ZOO_CFG = "mask_rcnn_R_101_DC5_3x.yaml"
OUTPUT_DIR = "checkpoints/models/T3_R101_DC53x"

# ---------------------------------------------------------------------#
# ----------------------------  HOOK CLASS  ---------------------------#
# ---------------------------------------------------------------------#
class LossHistory(HookBase):
    """Record and plot total / cls / box‑reg / mask loss during training."""

    def __init__(self, log_period: int, output_dir: str) -> None:
        self.log_period = log_period
        self.output_dir = output_dir
        self.history = []  # [(iter, total, cls, box, mask), …]
        self.csv_path = os.path.join(output_dir, "loss_history.csv")

        os.makedirs(output_dir, exist_ok=True)
        with open(self.csv_path, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(
                ["iteration", "total_loss", "loss_cls", "loss_box_reg", "loss_mask"]
            )

    # ----------------------------------------------------- #
    # Detectron2 will call these automatically via HookBase #
    # ----------------------------------------------------- #
    def after_step(self) -> None:
        """Log losses every `log_period` iterations."""
        iteration = self.trainer.iter
        if iteration % self.log_period != 0:
            return

        storage = self.trainer.storage

        def _extract(key: str) -> float:
            raw = storage.latest().get(key)
            return float(raw[0]) if isinstance(raw, (tuple, list)) else float(raw)

        total = _extract("total_loss")
        cls = _extract("loss_cls")
        box = _extract("loss_box_reg")
        mask = _extract("loss_mask")
        self.history.append((iteration, total, cls, box, mask))

        with open(self.csv_path, "a", newline="") as f:
            csv.writer(f).writerow([iteration, total, cls, box, mask])

    def after_train(self) -> None:
        """Plot the recorded loss curves when training finishes."""
        if not self.history:  # nothing recorded
            return

        its, totals, clss, boxes, masks = zip(*self.history)
        plt.figure()
        plt.plot(its, totals, label="total_loss", color="black", linewidth=2)
        plt.plot(its, clss, label="loss_cls")
        plt.plot(its, boxes, label="loss_box_reg")
        plt.plot(its, masks, label="loss_mask")
        plt.xlabel("Iteration")
        plt.ylabel("Loss")
        plt.title("Training Loss Curves")
        plt.grid(True)
        plt.legend()
        out_path = os.path.join(self.output_dir, "loss_curves.png")
        plt.savefig(out_path)
        plt.close()
        print(f"[LossHistory] Saved curve to: {out_path}")


# ---------------------------------------------------------------------#
# -------------------------  TRAINER CLASS  ---------------------------#
# ---------------------------------------------------------------------#
class CellSegTrainer(DefaultTrainer):
    """Custom trainer with tuned data‑loader, evaluator, hooks, optimiser."""

    @classmethod
    def build_train_loader(cls, cfg):
        """Return a dataloader with custom augmentations."""
        aug = [
            T.ResizeShortestEdge(
                short_edge_length=cfg.INPUT.MIN_SIZE_TRAIN,
                max_size=cfg.INPUT.MAX_SIZE_TRAIN,
                sample_style="choice",
            ),
            T.RandomFlip(prob=0.5, horizontal=True, vertical=False),
            T.RandomRotation(angle=[-5, 5], expand=False),
            T.RandomBrightness(0.9, 1.1),
            T.RandomContrast(0.9, 1.1),
            T.RandomSaturation(0.9, 1.1),
        ]
        mapper = DatasetMapper(
            cfg,
            is_train=True,
            augmentations=aug,
            image_format=cfg.INPUT.FORMAT,
            use_instance_mask=True,
        )
        return build_detection_train_loader(cfg, mapper=mapper)

    @classmethod
    def build_evaluator(cls, cfg, dataset_name, output_folder=None):
        """Use COCO AP metrics for evaluation."""
        output_folder = output_folder or os.path.join(cfg.OUTPUT_DIR, "inference")
        return COCOEvaluator(dataset_name, cfg, False, output_folder)

    def build_hooks(self):
        """Append best‑checkpoint and loss‑history hooks."""
        hooks = super().build_hooks()
        hooks.append(
            BestCheckpointer(
                self.cfg.TEST.EVAL_PERIOD, self.checkpointer, metric_name="bbox/AP"
            )
        )
        hooks.append(LossHistory(self.cfg.TEST.EVAL_PERIOD, self.cfg.OUTPUT_DIR))
        return hooks

    @classmethod
    def build_optimizer(cls, cfg, model):
        """Apply linear LR scaling w.r.t. batch size before building optimiser."""
        cfg.SOLVER.BASE_LR *= cfg.SOLVER.IMS_PER_BATCH / 16
        return super().build_optimizer(cfg, model)


# ---------------------------------------------------------------------#
# -----------------------------  MAIN  --------------------------------#
# ---------------------------------------------------------------------#
def main() -> None:
    # -------------------- Dataset registration -------------------- #
    register_coco_instances(DATASET_NAME, {}, JSON_PATH, IMG_DIR)
    MetadataCatalog.get(DATASET_NAME)  # ensure metadata is initialised
    DatasetCatalog.get(DATASET_NAME)   # ensure dataset is registered

    # -------------------- Build Detectron2 cfg -------------------- #
    cfg = get_cfg()
    cfg.merge_from_file(
        model_zoo.get_config_file(f"COCO-InstanceSegmentation/{MODEL_ZOO_CFG}")
    )

    # Dataset & dataloader
    cfg.DATASETS.TRAIN = (DATASET_NAME,)
    cfg.DATASETS.TEST = (DATASET_NAME,)
    cfg.SOLVER.IMS_PER_BATCH = BATCH_SIZE

    # Training schedule
    cfg.SOLVER.MAX_ITER = MAX_ITER
    cfg.SOLVER.CHECKPOINT_PERIOD = EVAL_PERIOD
    cfg.TEST.EVAL_PERIOD = EVAL_PERIOD

    # Anchor sizes tuned for small nuclei
    cfg.MODEL.ANCHOR_GENERATOR.SIZES = [ANCHOR_SIZES]

    # Model meta
    cfg.MODEL.ROI_HEADS.NUM_CLASSES = NUM_CLASSES
    cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(
        f"COCO-InstanceSegmentation/{MODEL_ZOO_CFG}"
    )

    # LR & warm‑up
    cfg.SOLVER.BASE_LR = 0.0025
    cfg.SOLVER.WARMUP_METHOD = "linear"
    cfg.SOLVER.WARMUP_ITERS = 1_000
    cfg.SOLVER.WARMUP_FACTOR = 1.0 / 1_000

    # Mask format
    cfg.INPUT.MASK_FORMAT = "bitmask"

    # Output directory
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    cfg.OUTPUT_DIR = OUTPUT_DIR

    # Save final cfg for reproducibility
    with open(os.path.join(cfg.OUTPUT_DIR, "config.yaml"), "w") as f:
        f.write(cfg.dump())

    # ------------------------- Train ------------------------- #
    trainer = CellSegTrainer(cfg)
    trainer.resume_or_load(resume=False)
    trainer.train()


if __name__ == "__main__":
    main()
